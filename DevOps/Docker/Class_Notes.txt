######################
Day 18: 2nd Jan. 2026
######################	
		
	Containerization using Docker ::::
	
		- What is Containerization?
		
			- It is a process of packaging the applications along with its dependencies.		
		
		DevOps - Micro-Services are deployed with Containers/Kubernetes		
	
	Virtual Machines :::
	
		- VMs are called as Hardware Level Virtualization 
		- VMs are created using Hypervisor
		- VMs are used to excute Operating Systems, by default.
		- VMs can run even if there is no active task/application
		- VMs consume more time and space to start-up the application
		
		
Next :::
	
	Containers :::
		
	Docker 

######################
Day 19: 5th Jan. 2026
######################		
		
	
	Containerization using Docker ::::		
		
		
		- It is a process of packaging the applications along with its dependencies.			
		
		
	Virtual Machines :::
	
		- VMs are called as Hardware Level Virtualization 
		- VMs are created using Hypervisor
		- VMs are used to excute Operating Systems, by default.
		- VMs can run even if there is no active task/application
		- VMs consume more time and space to start-up the application

	Containers :::
	
		- Containers are called as OS Level Virtualization 
		- Containers are created using Container-Engine(Docker)
		- Containers are used to excute the Tasks/Applications. Not Operating System, by default.
		- Containers will immediately goes to EXIT state, if there is no active task/application.
		- Containers consume less time and space to start-up the task/application.	
		- Containers run in its own dedicated/Isolated Address Space.
		- Containers uses the properties of the Underlying OS.
			- Namespace & Control Groups ==> Kernel Properties 
		- Containers can be used to reduce the no.of VMs. But we cannot completely eliminate the VMs.			
	
	Terminologies :::
	
		- Containerization 		#	It is a process of packaging the applications along with its dependencies.
		
		- Container-Engine		# 	It is used to Create and Manage the Containers and Container Images.
		
		- Container Images 		# 	It is a static file, defines the properties and depedencies of the Application/Container.
									It is Non-Executable
									It composed of various layer of Instructions created using Dockerfile.
									
		- Containers 			# 	Executable entity of the Container-Image

		- Container Registry	# 	It is used to Store and Manage the versions of Container-Images 
									Eg.: DockerHub 
									https://hub.docker.com/
									
		- Container Repository	#	It is a subset of Container Registry
		
		
		CI :
		
		GitHub Repo.								Artifactory Libraries				DockerHub
													(Jfrog)
													
			Source_Code:							Application Artifact				Application Image
			
			web_app.java_v1.0		--> Build --> 	web_app.war_v1.0			-->		web_app_Image:v1.0
		
			web_app.java_v1.1		--> Build --> 	web_app.war_v1.1			-->		web_app_Image:v1.1		
				
				
	
	Working with Containers :::
	
	
	- Infra-Structure Perspective	:::
		
			Jenkins_Master (VM)			==> To Create Jenkins CI/CD Pipeline Projects and schedule to the builds in the slave_nodes
																	
				Jenkins_SlaveNode1 (VM)	==> Perform Application Builds - Java Applications 
				Jenkins_SlaveNode2 (VM)	==> Perform Application Builds - .Net Applications			
				Jenkins_SlaveNode3 (VM)	==> Perform Application Builds - Python Applications 
				Jenkins_SlaveNode4 (VM)	==> Perform Application Builds - Angular/NodeJS
				Jenkins_SlaveNode5 (VM)	==> Perform Application Builds - Ruby 	


			Using Containers :::
		
			Jenkins_Master (VM)				==> To Create Jenkins CI/CD Pipeline Projects and schedule to the builds in the slave_nodes
			
				Jenkins_SlaveNode1 (VM) 	==> Install Container-Engine
					C1 	- Java Applications 
					C2	- .Net Applications	
					C3  - Python Applications
					C4  - Angular/NodeJS
					C5  - Ruby 	
				
	
	
	- Developers/Deployment Perspective :::
		
		
		Dev Environment :
			
			Developers :
			
				- Create Source Code 							mywebapp.java_V1.0 		jdk17
				
				- Application Build 				
				
				- Create Application Artifact					mywebapp.war_V1.0 
				
				- Perform Unit Testing - using Tomcat:8.5,jdk17 	


			Using Containers :
			
				- Containerize the Application along with its depedencies.
				
					- Package the Application:
					
						- (mywebapp.war_V1.0,Tomcat:8.5,jdk17)		--> mywebapp_Image:V1.0	
						
						- Publish the Image to Container Registry(DockerHub)
				
				
		QA Environment (VM):		Using Container Engine, Pull the Application Image from DockerHub
		
		
				- mywebapp_Image:V1.0	
				
				- Run that application as a Container.
		
		
		UAT Environment (VM):		Using Container Engine, Pull the Application Image from DockerHub
		
		
				- mywebapp_Image:V1.0	
				
				- Run that application as a Container.
				
		PROD Environment (VM):		Using Container Engine, Pull the Application Image from DockerHub
				
				- mywebapp_Image:V1.0	
				
				- Run that application as a Container.
		
				

	- Working with Containers:		
		
		- Create DockerHub Account
			- Login & Explore DockerHub Dashboard.		
		
		- Install Docker Container-Engine on a VM(Use Jenkins_SlaveNode1)
		
		- sudo -i 
		
		- apt install docker.io -y
		
	- Working with Docker Cli Commands :
	
		- docker --version 
		
		- docker images 				# To get the list of Container Images in the Local Machine 
		
		- docker ps 					# To get the list Active/Running Containers in the Local Machine 
		
		- docker ps -a 					# To get the list of Active and Inactive Containers in Local Machine
		
		- docker pull 					# To download an Image from DockerHub Registry
		
		- docker run <Image_Name>		# Create and run the Container based on the Container Image.
		
			docker run ubuntu
			
		- Modes of Container Execution: 
		
			- Foreground/Attached Mode 		# Default 
			
					docker run ubuntu		# Hold the terminal during execution
			
Next :::			
			- Background/Detached Mode :
		
		
			- Interactive Mode :
		

		
######################
Day 20: 6th Jan. 2026
######################		
		
	Docker Run Command Options :::

		
		- docker run <Image_Name>		# Create and run the Container based on the Container Image.
		
			docker run ubuntu
			
		- Modes of Container Execution: 
		
			- Foreground/Attached Mode 		# Default 
			
					docker run ubuntu		# Hold the terminal during execution
					
					docker run ubuntu sleep 20					
					
			- Background/Detached Mode :
			
					docker run -d ubuntu sleep 20		
		
			- Interactive Mode :	
			
					docker run -it ubuntu bash 		# Create and Run the container in an interactive Mode 
					
					exit							# Stop the Container 
		
		
		- Start Container :::
		
				- docker start <container_id>		# To start a container 
				
				Eg.: 				
					docker start 32d360c56b7d
		
		- Login to the running Container :::
		
				- docker exec -it <container_id> bash 		# Login to a contianer 
				
				- exit 										# Logoff 
				
				
				Eg.: 				
					docker exec -it 32d360c56b7d bash
					
					exit 
		
		
		- Stop Container :::	
				
				- docker stop <container_id>		# To stop a container 
				
				Eg.: 				
					docker stop 32d360c56b7d		
		
		
		- docker rm <container_id>					# Remove a container from local machine 


		- docker rmi <image>						# Remove an Image from local machine
		
		
	
	- Port Mapping/Binding ::::
	
		-> Used to Map the Container port and the host port.
		-> It used to expose the Container to internet.
		
		-p <host_port>:<container_port>
		
		Eg.: 	
		
			docker run -it -p 8085:8080 tomcat:8.0			# Create 1 Container 
		
			docker run -it -p 8086:8080 tomcat:8.0			# Ensure that the Host Port is unique!
		
		
	- docker inspect <docker_component_name>				
	
		Eg: 
		
			docker inspect <container_id>
		
			docker inspect <image_id>
		
			docker inspect <docker_volume_id>
			

		
	- Docker Container Volume ::::
	
		Used to maintain the persistant data.		
		
		Sign_in Service: 		
		
		3 - Tier Application :
		
			Front_End Layer		--> User Interface  	=> c1
			
			Application Layer 	--> Business Logic 		=> c2 
		
			Back_End Layer 		--> Data Base 			=> c3 
		
		
		Working with Volumes :
		
		
			docker volume list 					# To get the list of volumes 			
			
			docker volume create <vol_name>		# To Create a Docker Volume 	

			Eg.: 
			
				docker volume create pl-vol1	
			
			docker inspect <docker_volume_id>
			
			docker run -it ubuntu bash
			
			docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash
			
		
Next :::

		
	- Create the Container Images ::::
	
		- Docker Commit :::
				
				- It is used to Create a Container Image based on the existing Container reference.
				- Used by the Infra-Structure Management Team
			
		
		- Docker Build :::
	
				- It is used to Create a Container Image from the scratch based on the Dockerfile Instructions
				- Used by the Developers to Containerize the Applications


######################
Day 21: 8th Jan. 2026
######################	

	- Create the Container Images ::::
	
	- Docker Compose :::
	
	- Container Orchestration using Docker Swarm & Kubernetes :::
	

	- Create the Container Images ::::
	
		- Docker Commit :::	
				
				- It is used to Create a Container Image based on the existing Container reference.
				- Used by the Infra-Structure Management Team
				
				- To Create a Server Template! 
				
					Amazon AMI :::
				
				
			Syntax :::
			
				docker commit <Container_ID> <dockerhub_repository_name>/<New_Image_Name>:<tag>
				
				
				Eg.: 
				
					docker commit 32d360c56b7d loksaieta/pl-appbuild_img1:v1.0
					
					
	- Publish/Push Container Images to Container Registry ::::
	
	
		- docker login 		# Login to Container Registry using Docker cli.
		
			- User Name :
			
			- Password(Access Token) :
			
			- Create DockerHub Access Token :::
			
				- Login to DockerHub using Web Browser 
					- Goto setting and create one!
					
			
				To use the access token from your Docker CLI client:

				1. Run

				docker login -u loksaieta
				
				2. At the password prompt, enter the personal access token.

				asdfasdfsdsdafcscE
	
		
	
		- docker push <dockerhub_repository_name>/<New_Image_Name>:<tag>
		
			Eg.: 
			
				docker push loksaieta/pl-appbuild_img1:v1.0
				
		- docker pull loksaieta/pl-appbuild_img1:v1.0
			
		
	- Docker Build :::
	
		- It is used to Create a Container Image from the scratch based on the Dockerfile Instructions
		- Used by the Developers to Containerize the Applications	
		
		
		vi Dockerfile 
		
		FROM ubuntu		
		RUN apt update -y 
		RUN apt install git -y		
		RUN apt install maven -y
		
		
		Syntax: 
		
			docker build -t <dockerhub_repository_name>/<New_Image_Name>:<tag> .		# '.' refers to Dockerfile reference.
			
		Eg.: 
		
			docker build -t loksaieta/pl-javaappimg .

		Dockerfile Instructions ::::		
		
			FROM 									# To Identify the Base Image
			RUN 									# To run the package manager
			COPY 									# To Copy the file from host volume to container volume
			CP 										# To Copy the file within the container volumes 
			ADD 									# To Copy the file from Host Volume as well as from URL
			ENV 									# To define the Environment Variable 
			ARG 									# To pass Arguements to the Steps in Dockerfile 
			EXPOSE									# To Define the Container Port 
			WORKDIR									# To set the current working directory within the Container 
			CMD										# To set the default start-up command to the container 
													  This Command can be changed at run-time.
			ENTRYPOINT								# To set the default start-up command to the container 
													  This Command cannot be changed at run-time.	 
		
		
		Scenario :::
		
			Build_Server:
			
				--> Created target/*.war

				--> Create a Dockerfile to package this application using Tomcat
				
				
			vi Dockerfile 
			
			FROM tomcat:8.0
			COPY target/*.war /usr/local/tomcat/webapps
			EXPOSE 8080
		
		
